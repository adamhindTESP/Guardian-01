ü§ñ Guardian-01: The Benevolent Autonomous AI Robot
Guardian-01 separates semantic intent filtering from physical actuation control, enforcing safety through an independent hardware governor rather than trusting AI decisions alone.
This project demonstrates a robust, dual-veto safety architecture where high-level policy is governed by software, and physical constraints are governed by independent hardware.
‚ö†Ô∏è Scope & Limitations
Guardian-01 is a research and hobbyist platform. It is not safety-certified, not intended for unsupervised operation, and not a substitute for industrial safety systems. All safety claims refer to enforced physical limits, not guarantees of harmless behavior in all environments. Use responsibly.
üèóÔ∏è Architecture: The Cascaded Veto System
Safety is achieved by splitting authority across two independent systems: a software Policy Gate and a hardware Safety Governor. The Pi acts as the client, and the Teensy acts as the ultimate authority.
| Tier | Component | Function | Veto Authority |
|---|---|---|---|
| Tier 1 (Brain) | benevolent_robot.py | LLM Planning (Untrusted), High-Level Decision Making. | Autonomous Policy Gate (Semantic Veto): Filters policy/ethical violations. (Voluntary, but enforced by governance structure). |
| Tier 2 (Governor) | Teensy 4.1 (C++) | Motion Gating, Watchdog, Current Sensing. | Safety Governor (Physical Veto): Rejects any command that violates measured physics (force, time, current). Physically Authoritative. |
| Tier 3 (Power) | Motor Drivers, E-Stop Relay | Actuation and Energy Management. | Hardware Cutoff: E-Stop relay physically severs power to all motors. |
üîí Policy Veto (Tier 1: Semantic Filter)
Core Component: benevolence() function
The Python function serves as a Policy Gate, protecting the robot from semantic errors, manipulation, and policy violations generated by the LLM Planner.
 * Property: Fully stateless, auditable, and defined by explicit string heuristics and weighted thresholds.
 * Protection: Catches "bleach+ammonia" and social coercion attempts (MANIPULATION_DETECTED).
 * Limitation: It is blind to physical reality (voltage, current, torque) and must trust the caller's input for risk and dignity.
‚öôÔ∏è Physical Veto (Tier 2: Safety Governor)
Core Component: safety_mcu_firmware.cpp
The Teensy 4.1 runs the Safety Governor, which is the only component with direct control over the motor PWM signals. It enforces all constraints based on real-time sensor measurements.
| Safety Property | Enforcement Mechanism | Failure Mode Response |
|---|---|---|
| Independence | Runs C++ code separate from Pi's Linux OS. | Prevents OS crash/compromise from affecting actuation. |
| Watchdog | Pi must toggle pin every 100ms. | If silence \geq 500ms, LATCHES HARD_STOP state. |
| Rate Limiting | Enforces 30s continuous movement limit within a 60s rolling window. | Rejects movement commands exceeding limits. |
| Current Sensing | INA260 sensors constantly measure motor current. | \text{Current} > 8A: LATCH_SAFETY_FAULT. \text{Current} > 6A: Duty cycle reduced by 50%. |
| E-Stop | Physical mushroom switch opens the circuit powering the motor relay. | Immediate, non-software-based power cutoff. |
üõ†Ô∏è Technical Correction: Latching the Fault State
The Teensy firmware (safety_mcu_firmware.cpp) has been corrected to replace the infinite lock-up loop with a proper, latching fault state that allows for logging and communication.
 * The latch_safety_fault(reason) function disables all PWM and sets a permanent HARD_STOP flag.
 * The main loop() continues to run, allowing the Teensy to blink a fault code via the status LED and send telemetry to the Pi via Serial, maintaining a record of the failure cause.
üöÄ Deployment and Next Steps
 * BOM.md: Complete Bill of Materials and Ordering Guide.
 * safety_mcu_firmware.cpp: Code for the Safety Governor (Teensy 4.1).
 * benevolent_robot.py: Code for the Autonomous Policy Gate (Raspberry Pi 5).
